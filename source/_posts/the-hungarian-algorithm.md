---
title: 浅谈匈牙利算法
date: 2018-03-09 12:52:01
tags: 
- ACM-ICPC
- Graph Theory
- Bipartite Matching
- The Hungarian Algorithm
category: Solutions
#mathjax: true
---

# 前言

国内好像管解决带权二分图最大匹配问题的算法叫 “KM算法”，不过我到 Wikipedia 上查的时候发现好像这个也可以被称作匈牙利算法，所以在本文中我就姑且管 ”KM算法” 也叫做 “匈牙利算法” 吧。

本文很大程度上借鉴了巨佬出的新书和网络上几篇优秀文章（具体列表可见文末）。本人向这些文章的作者们表示衷心感谢！


# 几点概念

## 二分图

**二分图 (Bipartite graph)** 是一种特殊的简单图，它的顶点可以被分为两个不相交的集合（$U$ 和 $V$），并且同属一个集合的点两两不相连 ($E_U = E_V = \varnothing$)。也就是说，如果一个图是二分图，它要么没有圈 (cycle)，要么所有圈包含边的个数均为偶数。

例如，下图 `Fig.1` 就是一个二分图。但是为了方便，我们通常将其画作 `Fig.2` 的样子。

![Fig.1 && 2](the-hungarian-algorithm/fig-1-to-2.png)

那么我们如何使用算法来判定二分图呢？

显然，我们可以使用**染色法**，即用黑白两种颜色来标记图中的节点，当一个节点被标记后，我们将所有与之相邻的节点都标记为相反的颜色。若在此染色过程中出现了冲突，那么就不是二分图，否则是二分图。


## 匹配

**匹配 (Matching)** 是边的集合 ($M \subset E$)，其中任意两条边都没有公共点。

例如，下图 `Fig.3` 中所有红的的边组成的集合就是 `Fig.2` 的一个匹配。而在其中，被标红的边被称作**匹配边**；匹配边所连接的点被称为**匹配点**。与之相反地，没有被标红的边被称作**非匹配边**，非匹配边所连接的点被称作**非匹配点**。

显而易见，对于一个二分图来说，可能会有很多种匹配。如果某二分图的某一个匹配包含的边的数量在该二分图所有匹配中最大，那么称这个匹配为**最大匹配**。例如，下图 `Fig.4` 就是 `Fig.2` 的最大匹配。

相似地，如果这个二分图带权，那么权值之和最大的匹配被称作**最大权匹配**。

![Fig.3 && 4](the-hungarian-algorithm/fig-3-to-4.png)


## 增广路径

**增广路径 (Augmenting Path)** 是一条连通两个未匹配点，且非匹配边和匹配边在其上交替出现的路径。

例如，下图 `Fig.6` 就是 `Fig.5` 的一条增广路径。

![Fig.5 && 6](the-hungarian-algorithm/fig-5-to-6.png)



# 无权二分图的最大匹配

## 思想

通过上面的概念，我们不难发现增广路径有一个十分重要的性质：**非匹配边比匹配边多一条**。因此，研究增广路径的意义是**改进匹配**。如果我们把增广路径中的非匹配边和匹配边交换，这样做不仅不会破坏匹配本身的性质（因为增广路径中所有的匹配边并不存在与其他点相连的匹配边），而且交换后匹配边的数目还会比原来多 1 条。

如果我们不停地寻找增广路径，并在每一次找到增广路径后交换增广路径中的匹配点和非匹配点以增加匹配边的数目，这样直到再也找不到增广路径时，我们就得到了该二分图的最大匹配。这就是**匈牙利算法**的本质，因此有时我们也称其为**增广路算法**。


## 步骤

1. 设 $S = \varnothing$，即把所有边都标记为未匹配边。
2. 寻找增广路径，接着把其上所有边的状态取反（即把匹配边都标记为未匹配边，未匹配边都标记为匹配边）。
3. 重复第 2 步，直到再也无法在图中找到增广路径。

显然，该算法的关键在于如何寻找增广路径。

匈牙利算法尝试**给每一个左部节点 $x$ 寻找一个右部节点 $y$**。右部节点 $y$ 能够与左部节点 $x$ 匹配，需要满足如下两个条件之一：

1. **$y$ 本身就是非匹配点**。在这种情况下，$x - y$ 本身就是一条非匹配边，则是一条长度为 $1$ 的增广路径。
2. **$y$ 已经与左部点 $x'$ 匹配，但从 $x'$ 出发能找到另一个右部节点 $y'$ 与之匹配**。在这种情况下，$x - y - x' - y'$ 为一条增广路。

我们可以使用 **深度优先搜素 (DFS)** 来递归地从左部节点 $x$ 出发寻找增广路径。若找到，则在回溯的时候把路径上的匹配状态取反。另外，在每一次搜索时，我们可以开一个 `bool` 数组来记录每个右部节点的访问情况，以避免重复搜索。


## 例子

下面我们举一个例子来演示匈牙利算法的大致过程（请配合图片下方的一段文字说明食用）：

![Fig.5 && 6](the-hungarian-algorithm/hungarian-unweighted-demo.png)

首先，我们从左1出发，找到右1，发现这两点可以匹配（满足条件1）。至此，我们找到了一条增广路径。在回溯时，我们将这条未匹配边标记为匹配边（见图2）。

然后，我们从左2出发，先找到右1，发现它已经与左1匹配了。接着我们递归，尝试给与之匹配的左1另外找一个匹配点。但是我们找不到，因此匹配失败（不满足条件2，见图3）。接着，我们找到右3并匹配成功，找到增广路径，回溯时将该边标记为匹配边（见图4）。

接着，我们从左3出发，找到右2，匹配成功（满足条件1），找到增广路径，回溯时标记该边为匹配边（见图5）。

最后，我们从左4出发，找到右3，发现它已经与左2匹配了。接着我们递归，尝试给与之匹配的左2另外找一个匹配点，我们找到了右4，找到增广路径（满足条件2），回溯并将增广路径上的所有非匹配边标记为匹配边。

至此，我们便找到了最大匹配，算法完成。


## 正确性

匈牙利算法实际上基于**贪心策略**。它的一个重要特点是：当一个节点成为匹配点后，至多因为找到增广路而更换匹配对象，但是**绝对不会从匹配点变成非匹配点**。

如果要更详细（但不够严密）地说明，我们可以从反证法考虑：

假设存在这样的**非最大匹配**，在其中已经无法找到增广路径。

$\because$ 当前匹配不是最大匹配

$\therefore$ 左右部均至少存在一个非匹配点

对于这两个非匹配点，我们可以分两种情况讨论：

1. **若这两个点间存在一条边**： 那么我们就找到了一条增广路径，与假设矛盾；
2. **若这两个点间不存在边：**
   1. **若这两个点可以与已有的匹配点相连**：那么我们完全可以将其加入增广路径里，与假设矛盾；
   2. **若这两个点不能与已有匹配点相连**：那么这两个点无法增加图中匹配边的数量，也就是说我们已经找到最大匹配了，与假设矛盾。


## 时间复杂度

对于每个左部节点，寻找增广路最多遍历一次整张二分图，因此该算法的复杂度为 $\mathcal{O}(NM)$。


## 代码 (C++)

**几点说明：**

在代码样例中 `fst` 代表左部元素，`snd` 代表右部元素。

`arr[][]` 是描述是否可匹配的一个二维数组。例如，`arr[x][y] == true` 意味着左部 $x$ 节点和右部 $y$ 节点间存在路径。

`sndMatch[]` 记录与右部节点相匹配的左部节点（即记录当前的所有匹配边）。例如，`sndMatch[y] == x` 意味着左部 $x$ 节点和右部 $y$ 结点间存在一条匹配边。在刚开始时我们将该数组所有元素初始化为 -1，代表所有边开始时都是未匹配边。

```cpp
bool arr[SIZE][SIZE], sndVisited[SIZE];
int sndMatch[SIZE];
int fstNum, sndNum;

// Find snd vertex for fst vertex 
bool canFind(int fstId)
{
    for (int i = 0; i < sndNum; i++)
    {
        // If edge exists and snd vertex has not been visited
        if (arr[fstId][i] && !sndVisited[i])
        {
            sndVisited[i] = true;
            
            // Two conditions mentioned above
            if (sndMatch[i] == -1 || canFind(sndMatch[i]))
            {
                sndMatch[i] = fstId;
                return true;
            }
        }
    }
    return false;
}

int hungarian()
{
    int ans = 0; 	// Number of edges in maximum bipartite matching
    for (int i = 0; i < fstNum; i++)
    {
        // Initialize every snd vertex as unvisited
        memset(sndVisited, false, sizeof(sndVisited));
        
        if (canFind(i))
        {
            ans++;
        }
    }
    return ans;
}
```


# 带权二分图的最大权匹配

**未完待续……**


# 参考文献

- 李煜东 - 《算法竞赛进阶指南》
- Renfei Song - [二分图的最大匹配、完美匹配和匈牙利算法](https://www.renfei.org/blog/bipartite-matching.html)
- liam0205 - [二分图最大匹配问题与匈牙利算法的核心思想](https://liam0205.me/2016/04/03/Hungarian-algorithm-in-the-maximum-matching-problem-of-bigraph/)