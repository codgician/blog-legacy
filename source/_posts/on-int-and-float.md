---
title: 乱谈int与float（真的很乱！）
date: 2017-08-18 22:43:10
tags: 
- C/C++
category: OI
---

# 前言

一年没碰C/C++后果然什么都不会了欸，开学考试怎么办啊orz

前几天好友终于也入了C/C++的邪教，问起了几个浮点相关的问题，让我终于意识到深陷现代语言泥潭的我早已忘却这些富有趣味但又基础地不能在基础的知识…… 在网上大量查阅相关资料后决定属文以记之。

# 先从int说起

## unsigned int

unsigned int就是没有符号的int，在内存里占用4 Byte，也就是32位。很容易得知其能存储的最小值为0，最大值则为$2^{32} - 1 = 4294967295$。

## int

int是带有符号的，因此其所占据的第0 ~ 31位中第31位是用于存储符号的（0为正，1为负）。当然你会问，既然所有位均为0时变量的值为0，那么符号位为1时剩余位为0表示的又是什么呢？

这里就要牵扯进*2的补码 (2’s complement，又称二补数)*的概念了。

> 一个数字的二补数就是将该数字作*比特反相运算（即一补数或反码）*，再将结果加1。在二补数系统中，一个负数就是用其对应正数的二补数来表示。(*Wikipedia*，有修改)

为了方便，我们假定一种只有8位的类int数据类型来举几个例子：

| 符号位  |               | =        |
| ---- | ------------- | -------- |
| 0    | 1 1 1 1 1 1 1 | **127**  |
| 0    | 0 0 0 0 0 1 0 | **2**    |
| 0    | 0 0 0 0 0 0 1 | **1**    |
| 0    | 0 0 0 0 0 0 0 | **0**    |
| 1    | 1 1 1 1 1 1 1 | **-1**   |
| 1    | 1 1 1 1 1 1 0 | **-2**   |
| 1    | 0 0 0 0 0 0 1 | **-127** |
| 1    | 0 0 0 0 0 0 0 | **-128** |

我们可以容易地总结出以下两点：

- 取负运算实际上就是取该数的2的补码 (~x + 1)。
- 有两个数的2的补码等于其本身：0和-128 (溢出了，所以就变成自己了)。

至此，我们也应该理解为什么int的取值范围是 -2147483648 ~ 2147483647 了。

# 再来看看float

有了以上知识我们就可以来看float了。float与int一样占用4个字节，有32位。这32位被分为三个部分：符号位(1位，存储正负)、阶码(8位，存储指数)、尾数(23位，存储尾数)。

| 31   | 30 ~ 23 | 22 ~ 0 |
| ---- | ------- | ------ |
| 符号位  | 阶码      | 尾数位    |

任意一个**二进制**浮点数$V$都可以表示为：

$$
V = (-1)^s * M * 2^E
$$
其中，$s$就是*符号位*，$M$就是有效数字（$1 \le M < 2$），$E$就是*指数*（没错，就是科学记数法）。

我们很容易发现，$M$的整数部分一定恒为1，那还存什么存？只用存$M$的小数部分就行了，所以尾数就是$M - 1$。

再结合前面对float三个部分的解释，不难发现阶码实际上就是一个8位长的无符号整数，范围为0 ~ 255。可惜科学记数法中指数是可以为负数的。怎么办？IEEE就取了中间数127，钦定实际指数$E$ = 阶码 - 127，这样指数就可取-127 ~ 128了。

另外，在存浮点数的时候，除了要考虑无限大的情况，还要考虑无限接近于0的情况。因此浮点类变量还会有最小正值这一限制。但总不至于因此就0也不存了吧？所以IEEE就再钦定阶码和尾数均为0是变量的值为0。另外，IEEE还钦定阶码为255时表示无穷，因此指数实际上范围是-126 ~ 127。

至此，我们就已经可以回答float类型变量小数点后可存多少位的问题了。$2^{23} = 8388608223=8388608$，因此**float类型最长（不完整地）可存储小数点后7位，但只能完整地存储小数点后6位。**

另外，我们也就很容易知道float最大能存储的值为${1.11111111111111111111111}_2 * 2^{127} \approx 3.40282E{+38}$（即：$3.40282 * 10 ^ {38}$）；能存储的最小正值（完整精度）为${1.00000000000000000000000}_2 * 2^{-126} \approx 1.17549E{-38}$。

但是，float也并不是不能表示比最小正值更小的正浮点数。若在运算过程中结果小于最小正值（即发生了下溢），计算机会把尾数位向右移，空出第一个二进制位的同时丢弃最后一个二进制位。这样虽然得到了结果，但却损失了精度。

我们以一个浮点数-235.125为例子：

$$-235.125 = -{100100101001.001}_2 = -{1.00100101001001}_2 * 2^{11}$$

因此，在存储这个数时，符号位为1（负数），指数为$11 + 127 = 138 = {10001010}_2$，尾数为${00100101001001000000000}_2$

至于double也是类似的了，这里也就懒得讨论了（逃

# 参考文献

排序顺序嘛……我才不会告诉你是乱序呢。

- 可爱的Void（yzh）orz
- Wikipedia - [补码](https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E8%A3%9C%E6%95%B8)
- adream307 - [float的内存结构](http://blog.csdn.net/adream307/article/details/7246993)
- andyhzw - [**C/C++中浮点数的存储方式](http://blog.chinaunix.net/uid-28458801-id-3507427.html)
- wenrang - [浮点数与IEEE浮点标准](http://blog.csdn.net/wenrang/article/details/5758759)

