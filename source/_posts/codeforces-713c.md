---
title: Codeforces 713C - Sonya and Problem Wihtout a Legend
date: 2018-05-08 16:08:00
tags: 
- ACM-ICPC
- Dynamic Programming
- Codeforces
category: Solutions
#mathjax: true
---

# 题面

现有一个由 $n$ 个正整数组成的数列，每一次操作可以选择将其中任一元素并对其 $+1$ 或者 $-1$。试求最少次数操作，使得最终数组严格递增（最终数组中元素的值可以小于等于 $0$）。

数据范围：

$1 \le n \le 3000$

$1 \le a_i \le 10^9$

[题目链接](http://codeforces.com/contest/713/problem/C)

# 两点性质

首先我们不妨先考虑一个简单一些的情况：我们要求最终数列**非严格递增**。

那么自然，对于任何一个 $a_i$，如果出现了 $a_i > a_j$ 这种尴尬的情况，那么既然要使得操作数尽可能小，我们只需把 $a_i$ 减小至 $a_j$ 或者把 $a_j$ 增大至 $a_i$ 就好了。也就是说，在这个过程中不会有新的值产生（即经过调整后的 $a_i$ 或者 $a_j$ 一定是原数组种出现过的值）。换句话说，**在满足操作数最小化的前提下，一定存在一种构造答案数列的方法，使得答案数列中每个元素的值都在原数列中出现过。**

具体的证明可以使用数学归纳法。

然而该题要求的是**严格递增**的数列，我们应如何使用上述性质呢？我们只需要**在原数组的基础上把第 $i$ 个元素的值减去 $i$ **就好了。最后再在得出的答案数列基础上把减去的值加回来，那么显然串中就不会出现相邻两元素值相等的情况了。

所以，后文中的讲解便是针对答案数列**非严格递增**的讲解了。

# 动态规划

## 设计状态

为了方便表述，我们记原数列为 $a$，答案数列为 $b$。

首先我们来设计状态。

我们用 $i$ 来表示阶段，意味着当前已经处理完了前 $i$ 个元素。可是光有 $i$ 还不够，在转移时我们需要确定 $b_i$ 的值才能确保答案的单调性。那我们不妨把 $b_i$ 也加入状态，令 $dp[i][j]$ 代表已处理完前 $i$ 个元素且 $b_i = j$ 时的最小操作数，不难得出状态转移方程：
$$
dp[i][j] = \min\limits_{0 \le k \le j} \{ dp[i - 1][k] \} + |arr[i] - j|
$$
由于 $j$ 的取值范围高至 $10^9$，因此我们不妨考虑对原数组进行离散化，使得 $j$ 的含义变为原数组中第 $j$ 大的元素。记原数组中第 $j$ 大元素的值为 $val[j]$，那么状态转移方程就变为：
$$
dp[i][j] = \min\limits_{0 \le k \le j} \{ dp[i - 1][k] \} + |arr[i] - val[j]|
$$


朴素的实现方法复杂度高达 $\mathcal{O}(N^3)$，这里提供两种优化思路。

## 优化思路一

我们不妨把所有的 $dp[i - 1][k] \ (0 \le k \le j)$ 称作求解 $\min\limits_{0 \le k \le j} \{ dp[i - 1][k] \}$ 时的**决策集合**。我们不难发现，随着 $j$ 增加的过程中决策集合中决策因子的数量只会变大而不会减小。因此我们可以考虑用单个变量 $\text{prevMinVal}$ 来维护这个最小值，并在计算每个 $j$ 之前将 $dp[i - 1][j]$ 加入决策集合中（即把 $\text{prevMinVal}$ 更新为其与 $dp[i - 1][j]$ 中的较小值，这样就可以保持 $\text{prevMinVal}$ 代表 $\min\limits_{0 \le k \le j} \{ dp[i - 1][k] \}$ ）。由此我们便可以省掉 $k$ 那一层循环使得复杂度降为 $\mathcal{O}(N^2)$。
$$
dp[i][j] = \text{prevMinVal} + |arr[i] - val[j]|
$$

[完整参考代码](https://github.com/codgician/ACM-ICPC/blob/master/Codeforces/713C/dp.cpp)

## 优化思路二

我们可以把 $dp[i][j]$ 的含义改为处理完前 $i$ 个元素并且 $b_i \le j$ 时的最小操作数，那么相应地，状态转移方程式为：
$$
dp[i][j] = 
\begin{cases}
dp[i - 1][j] = dp[i - 1][j] + |arr[i] - val[i]| & j = 1 \\
\min \{ dp[i - 1][j] + |arr[i] - val[i]|, dp[i][j - 1]\} & j > 1\\
\end{cases}
$$

其中 $ dp[i - 1][j] + |arr[i] - val[i]|$ 代表 $b_i = j$ 时的最小操作数，而 $dp[i][j - 1]$ 则代表 $b_i < j$ 时的最小操作数，两者中的最小值也就是 $dp[i][j]$ 啦。细节上为了方便可以把直接把 $dp[0][j]$ 全部初始化为 $0$。 这样做也可以省掉 $k$ 那一层循环使得复杂度降为 $\mathcal{O}(N^2)$。

[完整参考代码](https://github.com/codgician/ACM-ICPC/blob/master/Codeforces/713C/dp_alt.cpp)

# 神奇的数学方法

未完待续……